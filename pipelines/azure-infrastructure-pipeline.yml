# Azure DevOps Pipeline Template for Terraform
# This template can be reused for validate, plan, and apply stages
#
# RENAMED: This file was previously named 'terraform-job.yml'.
# Recommended new name: 'azure-infrastructure-pipeline.yml' or 'aks-terraform-pipeline.yml'.
#
# Rationale: The new name is more descriptive, aligns with Azure DevOps and IaC best practices, and makes the pipeline's purpose clear for all team members.

parameters:
  - name: terraformVersion
    type: string
  - name: azureSubscription
    type: string
  - name: tfstatePath
    type: string
  - name: terraformPath
    type: string
  - name: command
    type: string
  - name: commandOptions
    type: string
    default: ''
  - name: environment
    type: string
    default: ''
  - name: artifactName
    type: string
    default: 'tfplan'

jobs:
- job: TerraformJob
  displayName: 'Terraform ${{ parameters.command | title }} Job'
  timeoutInMinutes: 60
  condition: succeeded()
  steps:
    - checkout: self
      persistCredentials: true

    - task: TerraformInstaller@0
      displayName: 'Terraform Install'
      inputs:
        terraformVersion: ${{ parameters.terraformVersion }}
      continueOnError: false

    - task: TerraformTaskV2@2
      displayName: 'Terraform Init'
      inputs:
        provider: 'azurerm'
        command: 'init'
        backendServiceArm: ${{ parameters.azureSubscription }}
        backendAzureRmResourceGroupName: $(TerraformBackendResourceGroupName)
        backendAzureRmStorageAccountName: $(TerraformBackendStorageAccountName)
        backendAzureRmContainerName: $(TerraformBackendContainerName)
        backendAzureRmKey: ${{ parameters.tfstatePath }}
        ensureBackend: true
        allowTelemetryCollection: false
        workingDirectory: '$(System.DefaultWorkingDirectory)/${{ parameters.terraformPath }}/'
        backendAzureRmUseEntraIdForAuthentication: true
      continueOnError: false

    # Run Terraform command (validate/plan/apply)
    - task: TerraformTaskV2@2
      displayName: 'Terraform ${{ parameters.command | title }}'
      inputs:
        provider: 'azurerm'
        command: ${{ parameters.command }}
        commandOptions: ${{ parameters.commandOptions }}
        environmentServiceNameAzureRM: ${{ parameters.azureSubscription }}
        workingDirectory: '$(System.DefaultWorkingDirectory)/${{ parameters.terraformPath }}/'
      continueOnError: false
      env:
        ARM_CLIENT_ID: $(ARM_CLIENT_ID)
        ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
        ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)
        ARM_TENANT_ID: $(ARM_TENANT_ID)

    # Publish plan file as artifact if running plan
    - ${{ if eq(parameters.command, 'plan') }}:
      - publish: '$(System.DefaultWorkingDirectory)/${{ parameters.terraformPath }}/tfplan'
        artifact: ${{ parameters.artifactName }}
        displayName: 'Publish Terraform Plan Artifact'

    # Download plan file artifact if running apply
    - ${{ if eq(parameters.command, 'apply') }}:
      - download: current
        artifact: ${{ parameters.artifactName }}
        displayName: 'Download Terraform Plan Artifact'

    # Post-job cleanup (optional, for security)
    - script: |
        echo "Cleaning up sensitive files..."
        rm -f $(System.DefaultWorkingDirectory)/${{ parameters.terraformPath }}/tfplan
      displayName: 'Cleanup Terraform Plan File'
      condition: always()

# Best practices applied:
# - Job-level displayName, timeout, and condition
# - Secure variable handling with env
# - Artifact publish/download for plan/apply separation
# - continueOnError: false for critical steps
# - Comments for maintainability
# - Post-job cleanup for security
# - Parameter validation and defaults
# - persistCredentials for private repos
